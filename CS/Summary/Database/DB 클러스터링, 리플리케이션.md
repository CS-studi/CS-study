# DB 클러스터링, 리플리케이션

기본적인 데이터베이스는 실제 데이터를 저장하는 저장소와 요청을 처리하는 서버로 이루어져 있다. 

<br>

# Clustering
> __데이터베이스 서버__ 가 죽으면 어떻게 대응하지? -> 데이터베이스 서버를 여러개로 만들자! : 클러스터링

<br>

## 클러스터링의 장점
- `데이터 중복`

Replication이 적용된 Clustering 기법에서 __데이터 중복__ 은  여러 데이터베이스 서버 사이의 데이터 동기화를 위해 일어난다. 동일한 데이터를 여러 서버에 중복 저장함으로써 하나의 서버가 고장나더라도 다른 서버를 통해 데이터를 제공할 수 있다. (RDB에서 __데이터 중복__ 은 데이터 일관성을 해지는 요소이지만, Clustering의 "데이터 중복"은 장애 극복 역할의 요소라 할 수 있다.)

- `로드 밸런싱`

여러 데이터베이스 서버로 부하를 분산시켜 사용자의 요청을 더 많이 수용할 수 있다. -> 누가 부하 분산을 조절할까?

- `높은 가용성`

여러 대의 데이터베이스 서버를 가지므로 높은 가용성을 보장한다.

<br><br>

## 클러스터링의 종류

<br>

1. `Clustering(Active - Active)`: 여러 대로 나눈 서버를 모두 Active 상태로 두는 방식이다.

__장점__
- `무중단 서비스 가능`

하나의 서버가 죽더라도 다른 Active 서버가 대신 요청을 받을 수 있기 때문에 중단없이 서비스를 제공할 수 있다.

- `성능적인 측면에서 이득`

서버가 2대가 운영되기 때문에 리소스를 많이 사용하게 된다. 이는 리소스 소모가 크다는 단점을 갖기도 하지만 성능적인 측면에서 이득이 있다.

__단점__
- `병목 현상`

두 대의 서버가 하나의 저장소를 공유하기 때문에 병목현상이 발생할 수 있다.

- `비용 문제`

두 대의 서버를 동시에 운용해야하기 때문에 비용이 많이 든다.

<br>

2. `Clustering(Active - Standby)`: 하나의 서버만 Active 상태로 두고, 다른 서버는 Stand by 상태로 두는 방식이다. 만약 Active 서버에 문제가 생겼을 때, Standby 상태의 서버를 Active 서버로 전환한다.

__장점__
- `비용 절감`

Standby 서버를 사용하지 않기 때문에 Active-Active 방식보다 비용을 절감할 수 있다.

__단점__
- `전환 시간이 오래걸린다.`

Active 서버에 문제가 생겨 Standby 서버를 Active 서버로 전환하는데 시간이 오래걸린다.(수십초~수십분)

<br><br>

# Replication
> __저장된 데이터가 손실__ 되면 어떻게 대응하지? -> 저장소를 복제하자!: Replication

기본적인 Replication 방식은 Primary DB와 Secondary DB로 구성된다.
- 사용자가 Primary DB로 CRUD를 요청하면 변경된 데이터를 Secondary DB에 동기화한다.
- Secondary DB는 단순한 백업(단순 백업) 및 조회 용도(부하 분산)로 사용한다.

일반적으로 하나의 Primary DB와 여러 개의 Secondary DB로 이루어진 구조에서 Read Only인 Secondary 노드들에 Write 가능한 Primary DB의 데이터가 업데이트되면 동기화시키는 방향으로 복제가 이루어진다.
- 기본적으로 비동기(Asynchronous)로 이루어진다.

<br>

## Replication을 사용하는 이유
- 데이터 유실을 막을 수 있다.

데이터가 여러 Replica에 복제되어 있기 때문에 한 데이터베이스에 문제가 발생하여 데이터가 삭제되더라도 다른 데이터베이스에 동일한 데이터가 저장되어 있기 때문에 데이터 유실 문제를 해결할 수 있다.

- Replica가 Primary DB의 역할을 할 수 있다.

Primary DB에 문제가 생겨 동작하지 않을 경우, Replica 중 하나가 Primary DB가 될 수 있다.

- 응답 지연 시간을 줄일 수 있다.

여러 군데에서 동일한 데이터를 저장하고 있는 여러 데이터베이스를 운영하면, 물리적인 위치에 관계없이 빠른 응답 속도를 보장한다. -> 비동기 방식으로 운영되기 때문이다.

<br><br>

## Replication Lag & 데이터 일관성

Primary DB에서 Secondary DB로 데이터를 복제하는데 걸리는 시간을 `Replication Lag` 라고 한다.

Replica가 많으면 Replication Lag 시간이 길어진다. 결국 시간차에 의해 Primary DB와 Secondary DB에서 동일 데이터를 조회할 경우 결과가 달라지게 되므로 데이터 일관성을 100% 지키지 못한다.

<br><br>

# Partitioning
> 하나의 큰 table을 `파티션(partition)` 이라는 작은 단위로 나누어 관리하는 기법

## 등장 배경

데이터의 규모가 대용량화 되면서, 기존에 사용하는 DB 시스템의 용량의 한계와 성능의 저하
하나의 DBMS에 너무 큰 table이 들어가면서 용량과 성능 측면에서 많은 이슈가 발생하였고 `Partitioning` 이 이러한 이슈를 해결

## 목적

- 특정 DML과 Query의 성능을 향상시킨다.

- 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.

- 큰 table들을 제거하여 관리를 쉽게 해준다.

## 장단점
- 장정
    - 파티션이라는 작은 단위로 나누어 관리하기 때문에 전체 데이터를 손실할 가능성이 줄어들어 데이터 가용성이 향상된다.
    - 파티션 단위로 I/O 분산이 가능하여 UPDATE 성능을 향상시킨다.
    - 데이터 전체 검색 시 필요한 부분만 탐색하기 때문에 Full Scan에서 데이터 Access의 범위를 줄여 성능 향상을 가져온다.

- 단점
    - table간 JOIN에 대한 비용이 증가한다.

<br><br>

# Sharding
> 데이터가 너무 많아서 검색이 느린데 더 빠르게 할 수 없을까? -> 테이블을 나눠서 검색하자!: Sharding

테이블을 Row(행) 단위로 나누어서 여러 Shard에 저장하는 방식이다.

타겟 데이터가 어떤 Shard에 존재하는지만 알면 검색을 빠르게 진행할 수 있다.

- Sharding 페이퍼를 구성하기 위해 고려해야할 사항 
1. 데이터를 분산된 데이터베이스에 어떻게 분산시켜 저장할지
2. 분산된 데이터베이스에서 데이터를 어떻게 읽을지

> Shard Key(나눠진 Shard 중 어떤 Shard를 선택할지 결정하는 키, Shard key 결정 방식에 따라 Sharding 방법이 나뉜다.)


## Sharding 방식

1. Hash Sharding: Hash Function을 사용하여 Shard Key를 결정하는 방식이다.
- 장점
    - 구현이 간단하다.
- 단점
    - Shard가 늘어나면 기존에 저장된 데이터들에 대한 정확성이 깨진다. -> Shard의 개수가 늘어나면 Hash Function의 계산 방식도 변하기 때문에 기존에 저장된 방식이 달라진다.(확장성이 떨어진다.) -> 근데 저장된 데이터들에 대한 정확성과 관련이 있나요?

    - Hash Function으로 Shard Key를 결정하기 때문에 공간 효율이 좋지 않다.

2. Dynamic Sharding: Locator Service 라는 테이블 정보를 기반으로 Shard Key를 결정한다.
- 장점
    - Shard 확장에 유연하다.
- 단점
    - Locator Service에 의존적인 방식이다.

3. Entity Group: 관계가 있는 Entity를 같은 Shard에 저장하는 방식이다.
- 장점
    - 단일 Shard 내에서 쿼리가 효율적이고 강한 응집도를 가진다.
- 단점
    - 다른 Shard의 Entity와 연관될 경우 비효율적이다.







