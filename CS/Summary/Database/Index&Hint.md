# Inde & Hint

> 순차 I/O, 랜덤 I/O

> 인덱스 레인지 스캔, 인덱스 풀 스캔

> 클러스터링 인덱스, 논 클러스터링 인덱스

> B-Tree Index, Hash Index

> Hint


## 랜덤 I/O와 순차 I/O
기본적으로 디스크 드라이브는 데이터를 읽을 때 원판 플래터를 회전하며 데이터를 찾는다.

- `순차 I/O`는 논리적/물리적 순서를 따라 차례대로 데이터를 읽어 나가는 방식
- `랜덤 I/O`는 논리적/물리적 순서를 따르지 않고 한 건의 데이터를 읽기 위해 한 블록씩 접근하는 방식

디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 따라서 보통 순차 I/O 가 랜덤 I/O 보다 빠르다고 볼 수 있다.

일반적으로 `쿼리 튜닝`은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하여 **랜덤 I/O 작업을 줄이는 것이 목적**이다. 순차 I/O로 바꿔서 실행할 방법이 적기 때문이다.

- `인덱스 레인지 스캔`은 **랜덤 I/O**를 사용
- `풀 테이블 스캔`은 **순차 I/O**를 사용
    - 매우 큰 테이블의 레코드를 읽을 때는 풀 테이블 스캔을 사용한다. (ex. 데이터 웨어 하우스, 통계 작업)

## 인덱스
`인덱스`는 DBMS의 **저장 성능을 희생하고 검색 성능을 높이기 위해** 만들어진 자료 구조이다.

> 인덱스의 목적 RDBMS의 검색 속도를 높이는데 있다.

### Index의 원리
Index를 해당 컬러에 주게 되면 초기 Table 생성시, FRM,MYD,MYI 3개의 파일이 만들어진다.

- FRKM: 테이블 구조가 저장되어 있는 파일
- MYD: 실제 데이터가 있는 파일
- MYI: Index 정보가 들어있는 파일

index를 사용하지 않는 경우, MYI 파일은 비어져 있다. 그러나 index를 해당 컬럼에 만들게 되면 해당 컬럼을 따로 인덱싱하여 MYI 파일에 입력한다.

이후에 사용자가 SELECT 쿼리로 index를 사용하는 쿼리를 사용 시 해당 Table을 검색하는 것이 아니라 **MYI 파일의 내용을 검색**한다.

### Index의 장점
- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다.
- 인덱스를 사용하면 테이블 행의 고유성을 강화시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

### Index의 단점
- 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- 인덱스된 필드에서 데이터를 업데이트(UPDATE)하거나 레코드를 추가(INSERT) 또는 삭제(DELETE) 할 때 성능이 떨어진다. (DML에 취약)
    - `Insert`
        - indext split : 인덱스의 Block들이 하나에서 두개로 나누어지는 현상.
        - 인덱스는 데이터가 순서대로 정렬되어야 한다. 기존 블록에 여유 공간이 없는 상황에서 그 블록에 새로운 데이터가 입력되어야 할 경우, 오라클이 기존 블록의 내용 중 일부를 새 블록에다가 기록한 후, 기존 블록에 빈 공간을 만들어서 새로운 데이터를 추가하게 된다.
        - Index split은 새로운 블록을 할당받고 Key를 옮기는 복잡한 작업을 수행한다. 모든 수행 과정이 Redo에 기록되고 많은 양의 Redo를 유발한다.
        - Index split이 이루어지는 동안 해당 블록에 대해 키 값이 변경되면 안되므로 DML이 블로킹된다.
    - `Delete`
        - ndex에서 데이터가 delete될 경우, 데이터가 지워지지 않고 사용 안됨 표시만 해둔다.
        - 즉, 테이블에 데이터가 1만건 있는 경우, 인덱스에는 2만건이 있을 수 있다는 뜻이다.
    - `Update`
        - 테이블에 update가 발생할 경우, 인덱스에서는 delete가 먼저 발생한 후 새로운 작업의 insert 작업이 발생한다.
        - delete와 insert 두 개의 작업이 인덱스에서 동시에 일어나 다른 DML보다 더 큰 부하를 주게 된다
- 인덱스가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다. (데이터베이스의 10% 내외의 공간이 추가로 필요)
- 인덱스를 생성하는데 시간이 많이 소요될 수 있다.
- 데이터 변경 작업이 자주 일어날 경우에 인덱스를 재작성해야 할 필요가 있기에 성능에 영향을 끼칠 수 있다.


## 인덱스 레인지 스캔 vs 인덱스 풀 스캔
- 인덱스 레인지 스캔
    - 테이블의 일부 레코드에만 엑세스해서 읽어들임
    - 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식
    - B Tree 인덱스의 가장 일반적인 엑세스 방식
    - 루트 노드 -> 브랜치 노드 -> 리프 노드 순으로 탐색
    - 리프 노드에서 시작할 지점을 찾으면, 그 다음부터는 리프 노드의 레코드만 순서대로 읽으면 된다.
    - 리프 노드의 끝까지 읽으면 리프 노드간의 링크를 통해 다음 리프 노드를 찾아서 스캔한다.
    - 최종적으로 스캔 종료 지점을 찾으면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 종료한다.
        - 데이터 파일에서 레코드를 읽어올 때 레코드 한건마다 랜덤I/O가 발생한다.
        - 그래서 인덱스를 통해 데이터를 읽는 작업은 비용이 많이 든다고 하는 것이다.
        - 인덱스를 통해 읽어야 할 데이터가 전체의 20%~25%를 넘으면 인덱스를 사용하지 않고 테이블 스캔 방식이 더 효율적인 처리 방식이 된다.
    - 주로, <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산을 이용하여 인덱스를 검색할 때 사용된다.

- 인덱스 풀 스캔
    - 테이블에 포함된 레코드를 처음부터 끝까지 읽어들인다.
    - 인덱스 풀 스캔은 인덱스의 처음부터 끝까지 모두 읽는 방식을 말한다.
        - 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식을 사용한다.
    - 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
    - 인덱스의 크기는 테이블의 크기보다 훨씬 작기 때문에 테이블 풀 스캔보다 빠른 방식이다.

- Full Table Scan
    - 테이블에 존재하는 모든 데이터를 읽어가면서 조건에 맞으면 결과로 추출하고 조건에 맞지 않으면 버리는 방식이다.