# 정규화

데이터베이스 정규화는 함수 종속성을 이용해 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해해서 이상 현상이 발생하지 않는 올바른 릴레이션으로 만들어 가는 과정이다.

- 정규화를 하는 이유
    - 불필요한 데이터 중복문제를 없앨 수 있고 삽입, 삭제, 갱신 시 발생할 수 있는 이상 현상을 방지할 수 있다.
    - 데이터 구조의 안정성과 무결성을 유지할 수 있다.
    - 효과적인 검색 알고리즘을 생성할 수 있다.

<br>

## 이상현상(Anomaly)
> 정규화를 거치지 않아 데이터베이스 내의 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예상하지 못하게 발생하는 현상

1. 삽입 이상: 의도하지 않은 데이터가 삽입되는 현상 또는 삽입이 되지 않아 발생하는 현상
2. 삭제 이상: 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제되는 현상
3. 갱신 이상: 일부의 튜플만 갱신되어 데이터 일관성이 깨지는 현상

이상 현상을 해결하기 위해 연관성이 높은 어트리뷰트들로만 릴레이션을 구성해야한다. -> 연관성을 평가하기 위한 척도에는 함수 종속성이 있다.

<br>

## 함수 종속성(FD: Functional Dependency)
> 같은 릴레이션 속의 어트리뷰트 값이 함수적으로 다른 어트리뷰트 값을 결정하는 종속 관계

어트리뷰트1 -> 어트리뷰트2로 어트리뷰트2의 값이 어트리뷰트1의 값에 의해 결정된다.
- 어트리뷰트1 = 어트리뷰트2를 결정하는 결정자
- 어트리뷰트2 = 어트리뷰트1에 종속된 종속자

<br>

1. 완전 함수 종속

```
{X, Y}(결정자) -> A(종속자)
X -/-> A
Y -/-> A
```

특정 어트리뷰트(`A`)가 둘 이상의 어트리뷰트 조합(`{X, Y}`)의 종속자이지만, 결정자의 일부 어트리뷰트(`X 또는 Y`)에는 종속자가 아닌 경우이다.

<br>

2. 부분 함수 종속

```
{X, Y}(결정자) -> A(종속자)
X(결정자) -> A(종속자)
Y(결정자) -> A(종속자)
```

특정 어트리뷰트(`A`)가 둘 이상의 어트리뷰트 조합(`{X, Y}`)의 종속자이고, 결정자의 일부 어트리뷰트(`X 또는 Y`)에도 종속자인 경우이다.

<br>

3. 이행적 함수 종속 관계

한 릴레이션의 어트리뷰트 A, B, C가 있을 때 어트리뷰트 C가 이행적으로 A에 종속(A->C)가 된다는 것의 필요충분 조건은 `A→B ∩ B→C 가 성립` 하는 것이다.

<br><br>

# 정규화 단계
- 정규화 과정을 진행하면서 데이터베이스의 바람직하지 않은 구조를 개선해 나간다.
- 보통 3차 정규화까지만 해도 충분하다고 하며 실무에선 비용의 문제로 정규화를 안하는 경우도 있다.(릴레이션 간의 join 연산이 증가하여 질의응답시간이 늘어날 수 있기 때문)


![](../../Database/img/Regularization/Untitled%209.png)

<br>

## 제 1차 정규화
> 1. 릴레이션의 모든 어트리뷰트가 원자값(Atomic)만 가져야 한다. 
> 2. 모든 어트리뷰트는 반복되지 않아야 한다.(동일한 성격의 어트리뷰트가 여러개 있으면 안된다.)

예시)

![](../../Database/img/Regularization/Untitled%2013.png)

![](../../Database/img/Regularization/Untitled%2014.png)

- 삽입 이상, 삭제 이상, 갱신 이상이 발생할 수 있다.

기본키인 `고객아이디, 이벤트번호` 에 완전 함수 종속되지 않고 그 일부분인 `고객아이디` 에만 종속되는 `등급, 할인율` 어트리뷰트가 존재하기 때문이다.(부분 함수 종속이 존재)

<br>

## 제 2차 정규화
> 제 1차 정규형에 속하면서 기본키가 아닌 모든 어트리뷰트들이 기본키에 완전 함수 종속이 된다. (제 1차 정규형에서 부분 함수 종속을 제거)

![](../../Database/img/Regularization/Untitled%2015.png)

![](../../Database/img/Regularization/Untitled%2016.png)

`고객아이디` 가 `등급` 을 통해 `할인율` 을 결정하는 이행적 함수 종속 관계를 없애기 위해 어트리뷰트를 분해한다.

<br>

- 이행적 함수 종속 관계가 존재한다.

<br>

## 제 3차 정규화
> 제 2차 정규형에 속하고 기본키가 아닌 모든 어트리뷰트가 기본키에 이행적 함수 종속이 아니다. (제 2차 정규형에서 이행적 함수 종속을 제거)

![](../../Database/img/Regularization/Untitled%2017.png)

![](../../Database/img/Regularization/Untitled%2018.png)

<br>

## BCNF(Boyce-Codd) 정규화
> 제 3차 정규형을 만족하면서 모든 결정자가 후보키 집합에 속한 정규형이다. (일반 어트리뷰트가 후보키를 결정하는 경우를 해결)

예시

제 3차 정규형으로 해결할 수 없는 이상현상을 해결할 수 있다.

<br><br>

# 반정규화

정규화를 하면 릴레이션 분리로 인해 릴레이션 간의 JOIN 연산이 많아져서 질의에 대한 응답 시간이 느려지는 문제가 있다. -> 반정규화 : 정규화를 진행한 다음에 필요에 의해 다시 릴레이션을 합치는 등 데이터를 중복시키는 작업

- 반정규화가 필요한 이유
    - 데이터를 조회하는데 지나치게 JOIN 연산이 많이 필요한 경우
    - 특정 데이터를 조회하는 횟수가 많고 특정 범위만 조회할 경우
    - 정규화에 충실하여 종속성, 활용성은 향상되었지만, 수행속도가 느려진 경우
    - 요약/집계 정보가 자주 요구되는 경우

> 정규화와 반정규화는 Trade off 관계

정규화를 하면 정합성과 데이터무결성이 보장된다. 반면 테이블이 복잡해지고 성능이 떨어질 수 있다. 그에 따라 입력, 수정, 삭제의 성능은 향상되고 조회의 경우 나빠질수도 있고 좋아질 수도 있다.

반정규화를 하면 테이블이 단순화 되어 쿼리 성능이 향상되는 반면 정합성과 데이터 무결성을 깨뜨리기 때문에 이상현상을 일으킬 수 있다.







