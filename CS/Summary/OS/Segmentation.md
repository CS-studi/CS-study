# Segmentation
=> 논리적 내용을 기반으로 나누어 메모리에 배치
<-> 기존의 페이징은 프로세스를 물리적 단위로 나누어 메모리에 할당했음.

Segmentation은 프로세스를 segment 집합으로 만들고, 각 세그먼트의 크기는 일반적으로 같지 않다.


- 가상주소는 세그먼트번호와 세그먼트 내의 위치(offset)으로 표현되고, 세그먼트 테이블의 시작주소에 세그먼트 번호를 더하여 해당 엔트리를 찾는 과정은 페이징과 같다.
- 세그먼트 테이블의 엔트리 {존재비트, 유효한 디스크 주소, 메모리 주소를 갖는 필드}
    - 페이징은 프레임 번호로 실주소를 위해 계산을 요구하지만, 세그먼트는 엔트리에 실주소를 가지고 있다
    - 엔트리에 해당 세그먼트가 적재된 메모리의 시작주소가 있다.
- 세그먼트의 길이가 적혀있는 필드는 세그먼트의 크기가 서로 다르기 때문에 segment overflow exception을 처리하기 위함이다. 세그먼트 번호가 segment 길이보다 클경우 overflow.

## Segment Protection & Sharing
=> Segment는 의미 단위이기 때문에 공유와 보안에 있어서 paging 보다 효과적이다.

- Protection
    - 각 세그먼트 별로 protection bit가 존재
    - 사상에서 실주소를 위해 더해지는 위치 값이 세그먼트의 길이 값을 초과하면 트랩을 통헤 프로세스의 실행을 중지시켜 사용자 간의 메모리 보호가 가능하다.
    - 접근 제어 키를 사용하여 세그먼트 별로 허용되는 작업을 제어하여 사용자의 잘못된 접근으로 부터 보호될 수 있다.
- Sharing
    - Shared segment
    - Same segement number
        - 공유하는 방법은 엔트리에서 같은 주소값을 가지도록하면 된다.
    - segment는 논리적으로 나누어져 있기 때문에 해당 논리안의 branch의 경우 내부적으로 얼마만큼 이동해야 하는지 알려준다. 이동은 segement 내부에서 이뤄지기 때문에 서로 다른 프로세스라도 문제가 되지 않는다.

### Segmentation의 장단점
__장점__
- 보호와 공유 면에서 효과적이다.
    - 두 user process가 동일한 코드(text segment)를 공유하기 용이하다
    - 각 memory section들에게 각기 다른 read, write 권한 설정할 수 있음
__단점__
- 세그먼트는 가변적이라 동적 메모리 할당을 해야함 -> 외부 단편화 발생(치명적인 단점)
- 평균 세그먼트 크기가 작을수록 외부 단편화 작음


## Segmentation w/ paging
=> 페이징의 편리함과 세그먼테이션의 논리적 장점을 함께 가지기 위한 기법이다.

1. 프로그램을 먼저 세그먼트 단위로 나눈 후, 각 세그먼트는 다시 페이지들로 나눈다.
2. 세그먼트 테이블의 각 엔트리는 나누어진 자신의 페이지들을 위한 페이지 테이블의 시작주소를 가지고 있다.
3. 가상주소 {세그먼트 번호, 페이지 번호, 페이지 내의 위치 값}이 참조되면, 세그먼트 테이블의 시작주소를 가지는 기준레지스터 값에 세그먼트 번호를 더해 세그먼트 엔트리를 검색한 후 해당 세그먼트의 시작주소를 알게 된다.
4. 페이지 테이블의 시작주소를 얻은 뒤에 가상주소에 페이지 번호를 더해 페이지 테이블 엔트리를 검색한다. 이를 통해서 page frame number를 얻게 된다. 마지막으로 물리주소의 시작주소부터 페이지 내의 위치값(offset)을 더하여 실제 주소에 접근한다.

___Segmentation w/ paging 기법은 사상을 위한 테이블의 전체 크기가 커지고 실주소 접근까지 메모리 접근이 더 요구되는 단점이 있지만 구현을 잘 했을 때 보호와 공유 면에서의 장점과 paging기법의 장점을 같이 가져갈 수 있기 때문에 운영체제에서 사용되고 있다.___