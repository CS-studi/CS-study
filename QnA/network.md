# ⁉️ Network QnA

<details>
<summary>GET과 POST의 차이점에 대해서 설명하시오.</summary>
<div markdown="2">       
GET 메서드는 정보를 조회하기 위한 메서드입니다.  요청하는 데이터가 HTTP Request Message의 Header 부분에 url이 담겨서 전송되는데 이 때 url 상에 쿼리 스트링으로 데이터를 붙여 request를 보냅니다. 이러한 방식은 url 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적입니다.  하지만 현재 주요 웹 브라우저에서 사용할 수 있는 URL 주소의 최대 길이는 익스플로러를 제외하면, 제한을 두지 않고 있습니다.

POST 메서드는 서버의 값이나 상태를 바꾸기 위한 용도의 메서드입니다. POST 방식의 request는 HTTP Request Message의 Body 부분에 데이터가 담겨서 전송이 되기 때문에 데이터를 전송할 때 길이 제한이 없습니다.

또 HTTP 메서드의 속성에는 계속해서 메서드를 호출해도 리소스를 변경하지 않는 안전, 메서드를 여러번 호출해도 결과가 달라지지 않는 멱등, 그리고 캐시 3가지 속성이 있는데 GET 메서드는 안전, 멱등의 특성을 가지고 캐시가 가능한 반면 POST는 안전, 멱등의 특성을 가지지 않고 캐시되지 않습니다.

조회하기 위한 용도로 POST가 아닌 GET 방식을 사용하는 이유에 대해서 설명하시오.

GET은 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 똑같을 것입니다. 반대로 POST는 리소스를 새로 생성하거나 업데이트할 때 사용되기 때문에 POST 요청이 발생하면 서버가 변경될 수 있기 때문에  조회에는 GET 방식을 사용합니다.
</div>
</details>

<details>
<summary>PUT 메서드와 PATCH 메서드의 차이점에 대해 설명하시오.</summary>
<div markdown="2">       
PUT과 PATCH는 요청된 자원을 수정할 때 사용한다는 공통점을 가지지만 PUT은 리소스의 모든 것을 업데이트하고 PATCH는 일부만을 업데이트 합니다.
가령 한 사용자에 대해 여러 정보를 객체로 수집하여 서버로 보내는 경우, PUT은 보내지지 않은 정보에 대해서는 null값으로 업데이트하지만, PATCH는 기존 데이터를 유지하는 방식으로 대응합니다.
</div>
</details>

<details>
<summary>HTTP Statue Code(HTTP 상태 코드) 의 종류에 대해 설명하시오.</summary>
<div markdown="2">       
먼저 100번대는 서버가 요청을 받았으며 서버에 연결된 클라이언트는 작업을 계속 진행하라는 의미입니다.
200번대는 서버가 요청을 성공적으로 받았음을 알려주고 300번대는 클라이언트의 요청에 대해 적절한 위치를 제공하거나 대안의 응답을 제공합니다. 그리고 400번대는 클라이언트에서 서버에 잘못된 요청을 보내 서버가 요청을 해결할 수 없을 때 발생하는 코드이며 클라이언트측에서 발생하는 코드입니다. 500번대는 클라이언트의 요청을 받고 서버에서 처리하지 못할때 발생하는 코드이며 서버측에서 발생하는 코드입니다.
</div>
</details>


<details>
<summary>HTTP와 HTTPS의 차이점을 설명하시오.</summary>
<div markdown="2">       
http는 client의 browser와 서버가 통신을 주고받게 해주는 프로토콜입니다. 서버로 데이터를 요청하거나 전송받을 때 http를 사용합니다. 하지만, http는 보호막을 씌우지 않은 형태이므로 보안에 취약합니다. 그래서 나온 것이 기존에 TCP로 통신을 하던 http위를 SSL이나 TLS로 감싼 형태가 HTTPS입니다.
</div>
</details>


<details>
<summary>HTTP의 문제점을 제시하시오.</summary>
<div markdown="2">       
`Http는 평문 통신`이기 때문에 도청이 가능합니다. 두번 째 문제점은 통신 상대를 확인하지 않기 때문에 `위장`이 가능하다는 점입니다. 마지막으로`완전성`을 증명할 수 없기 때문에 `변조`가 가능하기 때문에 위 세가지 문제점을 해결하기 위해 HTTPS를 이용합니다.
</div>
</details>

<details>
<summary>HTTP의 단점을 해결하기 위해서 어떻게 해야 하나요?</summary>
<div markdown="2">       
첫 번째로 SSL이나 TLS를 사용하여 다른 프로토콜과 조합하여 HTTP 통신 내용을 암호화 합니다. 즉 SSL를 사용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP 통신을 하는 것입니다.또 다른 방법으로 HTTP를 사용해서 운반하는 내용만을 암호화 하는 것입니다. 이 방법은 http 자체를 암호화 하는 것이 아닌 컨텐츠만 암호화하는 것인데 다만 이경우는 클라이언트에서 http 메시지를 암호화해서 출력하는 추가 처리가 요구됩니다. 세 번째 방법으로 위 암호화 방법으로 언급된 ssl을 통해서 상대를 확인할 수 있습니다. ssl은 상대를 확인하는 수단으로 증명서를 제공합니다. 마지막으로 md5, sha-sum 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아닙니다. 확실히 방지하기 위해서는 https를 사용해야 합니다.
</div>
</details>

<details>
<summary>HTTPS를 구체적으로 설명하시오.</summary>
<div markdown="2">       
https는 http+ ssl/tls 입니다. 엄밀히 말하면 http의 소켓 부분을 ssl과 tls로 대체하는 것이 https입니다. 기존의 http는 원래 tcp와 직접 통신했지만 https는 http의 부분은 ssl과 통신하고 ssl이 TCP와 통신을 하게 됩니다. https의 SSL에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스텝을 상요합니다. 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식입니다.
</div>
</details>


<details>
<summary>웹 통신의 큰 흐름에 대해 설명해보세요</summary>
<div markdown="2">       
  1. 사용자가 브라우저에 url을 입력하면 브라우저 내부 규칙에 따라 이를 파싱하여 도메인 네임을 얻습니다. 
    2. 도메인 네임에 해당하는 IP 주소를 찾기 위해 총 4 단계의 DNS 캐시를 살펴봅니다.
        
        브라우저 DNS 캐시 → OS의 DNS 캐시 → 라우터의 DNS 캐시 → ISP의 DNS 캐시를 살펴보고 찾고자 하는 IP 주소가 없다면 ISP DNS 서버가 DNS 쿼리를 날립니다.
        
    3. ISP DNS는 여러 다른 DNS 서버들에게 DNS 쿼리를 날리면, 서로 다른 DNS 서버사이를 오고가며 재귀적으로 IP 주소를 검색합니다. 이 과정을 Recursive Search라고 합니다.
    4. 도메인에 해당하는 IP 주소를 얻고나면, 클라이언트는 서버와 3 way handshake를 통해 TCP connection을 수립합니다.
        - 클라이언트는 서버와 통신을 요청하는 SYN 패킷을 보내고
        - 서버는 클라이언트의 SYN 패킷을 받은뒤, 이에 대한 응답으로 ACK 패킷과 자신도 클라이언트와 통신을 원한다는 의미의 SYN 패킷을 보냅니다.
        - 클라이언트는 서버의 SYN, ACK 패킷을 받고 서버의 SYN 패킷에 대한 응답으로 ACK 패킷을 보내므로써 TCP connection이 수립됩니다.
    5. TCP connection이 수립되었다면 클라이언트는 서버에게 데이터를 전송합니다.
        
        캡슐화를 통해 7계층에서 1계층으로 데이터에 헤더를 붙이고 데이터를 전기 신호로 변환해 스위치로 전송합니다.
        
        스위치에서 데이터를 2계층까지 역캡슐화합니다. 그로부터 얻은 Ethernet 헤더의 라우터 MAC 주소를 확인하여 해당 라우터와 연결된 포트로 전송합니다.
        
        라우터는 데이터를 2계층까지 역캡슐화합니다. 이후 MAC 주소가 자신의 MAC 주소와 같다면 3계층까지 역캡슐화합니다. 그로부터 얻은 IP 헤더의 목적지 IP 주소를 알아내고 최적의 경로로 라우팅을 진행합니다.
        
        목적지 라우터에서는 데이터의 IP 헤더 속 출발지 IP 주소를 목적지 라우터 내부 IP 주소로 변경합니다. 그리고 목적지 스위치로 전송하기 위해 데이터의 Ethernet 헤더 속 MAC 주소를 변경합니다.
        
        목적지 스위치에서 전기 신호의 데이터는 웹서버로 전달됩니다.
        
    6. 구글 서버는 데이터를 전달받습니다. 
        
        이 때, 전달받은 데이터를 1계층에서 7계층 순서로 역캡슐화합니다.
        
        2계층에서 `Ethernet 프레임의 목적지 MAC주소` 와 자신의 MAC 주소를 비교하여 같다면 3계층으로 올립니다
        
        3계층에서 `IP 프로토콜 헤더의 목적지 IP 주소` 와 웹 서버의 IP 주소를 비교하여 같다면 4계층으로 올립니다
        
        4계층에서 `TCP 헤더의 목적지 포트 번호` 를 확인하여 어떤 어플리케이션으로 데이터를 전달할지 정합니다. 만약 데이터에 오류가 있다면 재전송을 요청합니다. 이상이 없다면 5,6,7계층 순서로 전달합니다.
        
        5계층에서 데이터를 받고 이에 대한 응답 메시지를 만들어 클라이언트로 전달합니다. 전달되는 과정은 위 과정의 역순으로 진행됩니다.

</div>
</details>


<details>
<summary>클라이언트와 서버가 데이터를 주고 받을 때 캡슐화, 역캡슐화의 진행과정을 설명해보세요</summary>
<div markdown="2">       
        
    - 클라이언트의 캡슐화 과정
        1. 7계층(응용 계층)에서 `HTTPS의 헤더`가 먼저 붙는다. 6,5계층의 헤더가 붙고
        2. 4계층(전송 계층)에서 `TCP 헤더` 가 붙는다.
            
            TCP 헤더에는 신뢰할 수 있고 정확한 데이터 송수신을 위해 `출발지 포트번호` 와 `목적지 포트번호` 정보가 기록된다. 여기까지의 데이터를 `세그먼트(segment)` 라고 한다
            
        3. 3계층(네트워크 계층)에서 `IP 프로토콜의 헤더` 가 붙는다.
            
            IP 헤더에는 `출발지 IP주소` 와 `목적지 IP주소` 가 기록된다. 여기까지의 데이터를 `패킷(packet)` 이라고 한다
            
        4. 2계층(데이터 링크 계층)에서 `Ethernet`의 헤더가 붙는다.
            
            Ethernet 헤더에는 목적지로 가기위해 거쳐야할 IP주소를 가지고 있는 장비인 `라우터의 MAC 주소` 가 기록된다. 여기까지의 데이터를 `프레임(frame)` 이라고 한다.
            
        5. 1계층(물리 계층)에서 `LAN 카드` 라는 장비를 거쳐 데이터는 전기신호로 변환된다. 그리고 `케이블(UDP)` 와 물리적으로 연결되어있는 `스위치(switch)` 장비로 향한다. (보라색 선)
        
    - 서버의 역캡슐화 과정
        1. 2계층에서 `Ethernet 프레임의 목적지 MAC주소` 와 자신의 MAC 주소를 비교하여 같다면 3계층으로 올립니다
        2. 3계층에서 `IP 프로토콜 헤더의 목적지 IP 주소` 와 웹 서버의 IP 주소를 비교하여 같다면 4계층으로 올립니다
        3. 4계층에서 `TCP 헤더의 목적지 포트 번호` 를 확인하여 어떤 어플리케이션으로 데이터를 전달할지 정합니다. 만약 데이터에 오류가 있다면 재전송을 요청합니다. 이상이 없다면 5,6,7계층 순서로 전달합니다.
        4. 5계층에서 데이터를 받고 이에 대한 응답 메시지를 만들어 클라이언트로 전달합니다. 전달되는 과정은 위 과정의 역순으로 진행됩니다.
</div>
</details>


<details>
<summary></summary>
<div markdown="2">       

</div>
</details>

<details>
<summary></summary>
<div markdown="2">       

</div>
</details>