<details>
<summary>프로세스가 무엇인가요? (Context, Context Switching, Blocked 상태와 Suspended 상태 차이)</summary>

프로세스란 디스크에 실행 파일로 존재하던 프로그램이 메모리에 적재되어 실행되기 시작하면 프로세스라 부릅니다.

프로세스 컨택스트란 CPU 스케쥴링에 의해 CPU 점유권을 빼앗겼다가 다시 획득하게 되었을때 이전의 상태를 재현하기 위해 필요한 모든 정보를 말합니다.

- 프로세스 문맥은 크게 3가지로 나뉩니다.
    - CPU 의 수행 상태를 나타내는 하드웨어 컨택스트 = PC값, 레지스터값
    - 프로세스의 주소 공간 = code, data, stack
    - 프로세스 관련 커널 자료구조인 PCB

컨택스트 스위칭이란 CPU 점유권이 현재 프로세스에서 다음 프로세스로 넘어가는 과정에서 점유권을 빼앗기는 프로세스는 현재 컨택스트를 기억하기 위해 PCB에 CPU의 pc값과 레지스터 값을 저장해두고, 점유권을 얻는 프로세스는 이전의 컨택스트를 복원하기 위해 PCB의 pc값과 레지스터 값을 CPU에 복원합니다.

blocked 상태는 프로세스가 cpu 점유권을 가지고 명령어를 수행하다가 io작업과 같은 시간이 오래 걸리는 작업을 할경우의 상태입니다. 해당 프로세스는 cpu 점유권을 반환하고, io작업을 마치면 ready 상태가 되어 ready queue에 대기하여 cpu 스케쥴러에게 스케쥴링 당하길 기다립니다.

suspended 상태는 CPU 또는 외부(사람, 중기 스케쥴러)에 의해 강제로 정지당한 프로세스의 상태입니다. 이 상태의 프로세스는 메모리를 빼앗겨 디스크로 swap out되기 때문에 외부에서 재개 해줘야 active한 상태가 됩니다.

</details>


<details>
<summary>스케쥴러에 대해 아시나요? (스케쥴러 종류)</summary>

어떤 프로세스에게 자원을 할당해줄지 결정하는 운영체제의 커널 코드를 지칭합니다.

3가지 스케쥴러가 있습니다.

- 장기 스케쥴러 (job 스케쥴러)
    
    메모리 자원을 어떤 new 상태의 프로세스에게 할당할지 결정하는 스케쥴러입니다.
    
    이 스케쥴러는 메모리에 동시에 올라갈 프로세스의 수를 제어합니다. 보통 시분할 시스템에서는 장기 스케쥴러가 없습니다. (new 상태의 프로세스는 메모리를 할당받아 곧바로 ready 상태가 됩니다)
    
    따라서 메모리에 동시에 올라갈 프로세스의 수를 결정하는 것은 중기 스케쥴러에 의해 수행됩니다.
    
- 중기 스케쥴러 (swapper)
    
    중기 스케쥴러는 메모리에 동시에 많은 프로세스가 올라갈 경우, 일부 프로세스를 골라 메모리를 빼앗고 디스크로 swap out 시키는 역할을 합니다.
    
    중기 스케쥴러에 의해 메모리를 빼앗긴 프로세스는 suspended 상태가 됩니다.
    
- 단기 스케쥴러 (cpu 스케쥴러)
    
    cpu 점유권을 어떤 프로세스에게 할당할지 결정하는 스케쥴러입니다.
    
    스케쥴링이 일어나는 단위가 밀리세컨드로 굉장히 자주 일어납니다.

</details>


<details>
<summary>스레드가 무엇인가요?</summary>

스레드란 프로세스가 할당받은 자원을 이용하는 실행 단위입니다.

프로세스 하나에 CPU 수행 단위만 여러개 두었을 때 그 각각을 스레드라 합니다.

- 스레드마다 별도로 cpu 수행에 필요한 정보인 pc값과 레지스터 값이 필요합니다.
- 스레드는 프로세스의 주소 영역중 code, data 영역은 공유하지만 stack 영역은 독립적으로 가지고 있습니다. code 영역을 수행하다 함수 호출이 일어나면, 해당 함수에 관련된 정보를 stack에 쌓아 두기 때문에 스레드 마다 독립적인 stack 영역이 필요합니다.

만약 스레드가 없다면

- 동일한 작업을 수행하기 위해 여러 프로세스를 생성하면, 각각의 메모리 주소 공간과 PCB가 독립적으로 만들어져 메모리 공간 낭비가 심해집니다.

</details>


<details>
<summary>멀티 프로세스, 멀티 스레드의 장단점에 대해 설명해보세요</summary>

멀티 프로세스는

- 하나의 프로그램을 다수의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하는 것입니다.
- 장점
    - 각 프로세스 마다 독립된 메모리 공간을 가지기 때문에 하나의 프로세스에 오류가 발생해도 다른 프로세스에 영향이 없습니다.
- 단점
    - 독립된 메모리 영역을 가지기 때문에 컨택스트 스위칭이 자주 일어나 오버헤드가 발생합니다.
    - 프로세스 간에 통신이 원칙적으로 제한되어 있지만, 그럼에도 불구하고 별도의 통신을 IPC를 통해 수행합니다. 예를 들어 shared memory 방식을 사용하면 커널로부터 프로세스끼리 공유할 메모리를 할당받고, 공유 메모리 공간을 통해 통신을 할 수 있습니다. 다만 공유 자원에 대한 동기화 문제를 해결해야 합니다.

멀티 스레드는

- 하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것입니다
- 장점
    - 일단 하나의 프로세스의 메모리 공간 code, data과 자원을 공유하기 때문에 효율적인 자원활용이 가능합니다. 또한 프로세스의 IPC와 같은 통신을 위한 기술이 필요하지 않습니다.
    - 응답성이 높습니다. 웹 브라우저의 하나의 탭에서 하나의 스레드가 웹 페이지를 다운 받으면, 그와 동시에 다른 스레드가 다운 받은 html을 화면에 출력하는 상황처럼 응답성을 높힐 수 있습니다.
- 단점
    - 여러 스레드끼리 자원을 공유하기 때문에 그에 따른 동기화 문제가 발생할 수 있습니다. 동기화 문제는 뮤텍스, 세마포어 방식을 활용하여 해결할 수 있습니다.
    - 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받습니다.

</details>



<details>
<summary>IPC에 대해서 설명해보세요</summary>

IPC란 프로세스간에 통신 기법입니다.

프로세스 끼리의 통신은 원칙적으로 제한되어있지만 IPC 기법을 통해 통신을 할 수 있습니다.

대표적으로 shared memory, message passing 기법이 있습니다.

message passing

- 프로세스가 커널을 통해 메시지를 주고 받으며 통신하는 방법입니다.
- 통신하려는 프로세스의 이름을 명시적으로 표시하여 전달하는 direct communication방식과
- mailbox또는 port를 통해 메시지를 간접적으로 전달하는 indirect communication 방식이 있습니다.

shared memory 방식을 사용하면 

- 커널로부터 프로세스끼리 공유할 메모리를 할당받고, 공유 메모리 공간을 통해 통신을 할 수 있습니다. 다만 공유 자원에 대한 동기화 문제를 해결해야 합니다.

</details>

<details>
<summary>CPU 스케줄링이 무엇인지와 목적을 설명해주세요.</summary>
CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드입니다.
CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 효율적인 CPU 사용을 위해 필요합니다.
</details>

<details>
<summary>비선점방식과 선점방식을 설명해주세요.</summary>
비선점 방식은 프로세스가 CPU를 점유하고 있는 경우 다른 프로세스가 CPU를 빼앗지 못하는 방식입니다. 비선점방식은 CPU를 중간에 가로채지 않기 때문에 응답시간 예측이 용이하다는 장점이 있지만 중요한 작업이 오래 기다리는 경우가 발생할 수 있다는 단점이 있습니다.
선점 방식은 프로세스가 CPU를 점유하고 있어도 우선 순위가 높은 프로세스가 오면 CPU를 빼앗을 수 있는 방식입니다. 선점방식은 우선 순위가 높은 프로세스가 빠르게 처리할 수 있다는 장점이 있지만 잦은 Context Switching으로 오버헤드가 증가한다는 단점이 있습니다.
</details>

<details>
<summary>스케줄링 기법 중 FCFS의 단점과 해결 방법을 설명해주세요.</summary>
FCFS 는 대기 큐에 도착한 순서에 따라 CPU를 할당합니다. 그래서 긴 작업이 짧은 작업을 오랫 동안 기다릴 수 있습니다.
단점을 해결하는 방법으로는 준비 큐에서 기다리고 있는 프로세스 중 가장 CPU 요구량이 적은 것을 먼저 실행시켜 주는 SJF(Shortest Job First)가 있습니다.
</details>

<details>
<summary></summary>

</details>
