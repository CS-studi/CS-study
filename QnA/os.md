# 🫁 OS QnA

<br>

<details>
<summary>프로세스가 무엇인가요? (Context, Context Switching, Blocked 상태와 Suspended 상태 차이)</summary>

프로세스란 디스크에 실행 파일로 존재하던 프로그램이 메모리에 적재되어 실행되기 시작하면 프로세스라 부릅니다.

프로세스 컨택스트란 CPU 스케쥴링에 의해 CPU 점유권을 빼앗겼다가 다시 획득하게 되었을때 이전의 상태를 재현하기 위해 필요한 모든 정보를 말합니다.

- 프로세스 문맥은 크게 3가지로 나뉩니다.
    - CPU 의 수행 상태를 나타내는 하드웨어 컨택스트 = PC값, 레지스터값
    - 프로세스의 주소 공간 = code, data, stack
    - 프로세스 관련 커널 자료구조인 PCB

컨택스트 스위칭이란 CPU 점유권이 현재 프로세스에서 다음 프로세스로 넘어가는 과정에서 점유권을 빼앗기는 프로세스는 현재 컨택스트를 기억하기 위해 PCB에 CPU의 pc값과 레지스터 값을 저장해두고, 점유권을 얻는 프로세스는 이전의 컨택스트를 복원하기 위해 PCB의 pc값과 레지스터 값을 CPU에 복원합니다.

blocked 상태는 프로세스가 cpu 점유권을 가지고 명령어를 수행하다가 io작업과 같은 시간이 오래 걸리는 작업을 할경우의 상태입니다. 해당 프로세스는 cpu 점유권을 반환하고, io작업을 마치면 ready 상태가 되어 ready queue에 대기하여 cpu 스케쥴러에게 스케쥴링 당하길 기다립니다.

suspended 상태는 CPU 또는 외부(사람, 중기 스케쥴러)에 의해 강제로 정지당한 프로세스의 상태입니다. 이 상태의 프로세스는 메모리를 빼앗겨 디스크로 swap out되기 때문에 외부에서 재개 해줘야 active한 상태가 됩니다.

</details>

<br>


<details>
<summary>스케쥴러에 대해 아시나요? (스케쥴러 종류)</summary>

어떤 프로세스에게 자원을 할당해줄지 결정하는 운영체제의 커널 코드를 지칭합니다.

3가지 스케쥴러가 있습니다.

- 장기 스케쥴러 (job 스케쥴러)
    
    메모리 자원을 어떤 new 상태의 프로세스에게 할당할지 결정하는 스케쥴러입니다.
    
    이 스케쥴러는 메모리에 동시에 올라갈 프로세스의 수를 제어합니다. 보통 시분할 시스템에서는 장기 스케쥴러가 없습니다. (new 상태의 프로세스는 메모리를 할당받아 곧바로 ready 상태가 됩니다)
    
    따라서 메모리에 동시에 올라갈 프로세스의 수를 결정하는 것은 중기 스케쥴러에 의해 수행됩니다.
    
- 중기 스케쥴러 (swapper)
    
    중기 스케쥴러는 메모리에 동시에 많은 프로세스가 올라갈 경우, 일부 프로세스를 골라 메모리를 빼앗고 디스크로 swap out 시키는 역할을 합니다.
    
    중기 스케쥴러에 의해 메모리를 빼앗긴 프로세스는 suspended 상태가 됩니다.
    
- 단기 스케쥴러 (cpu 스케쥴러)
    
    cpu 점유권을 어떤 프로세스에게 할당할지 결정하는 스케쥴러입니다.
    
    스케쥴링이 일어나는 단위가 밀리세컨드로 굉장히 자주 일어납니다.

</details>

<br>

<details>
<summary>스레드가 무엇인가요?</summary>

스레드란 프로세스가 할당받은 자원을 이용하는 실행 단위입니다.

프로세스 하나에 CPU 수행 단위만 여러개 두었을 때 그 각각을 스레드라 합니다.

- 스레드마다 별도로 cpu 수행에 필요한 정보인 pc값과 레지스터 값이 필요합니다.
- 스레드는 프로세스의 주소 영역중 code, data 영역은 공유하지만 stack 영역은 독립적으로 가지고 있습니다. code 영역을 수행하다 함수 호출이 일어나면, 해당 함수에 관련된 정보를 stack에 쌓아 두기 때문에 스레드 마다 독립적인 stack 영역이 필요합니다.

만약 스레드가 없다면

- 동일한 작업을 수행하기 위해 여러 프로세스를 생성하면, 각각의 메모리 주소 공간과 PCB가 독립적으로 만들어져 메모리 공간 낭비가 심해집니다.

</details>

<br>


<details>
<summary>멀티 프로세스, 멀티 스레드의 장단점에 대해 설명해보세요</summary>

멀티 프로세스는

- 하나의 프로그램을 다수의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하는 것입니다.
- 장점
    - 각 프로세스 마다 독립된 메모리 공간을 가지기 때문에 하나의 프로세스에 오류가 발생해도 다른 프로세스에 영향이 없습니다.
- 단점
    - 독립된 메모리 영역을 가지기 때문에 컨택스트 스위칭이 자주 일어나 오버헤드가 발생합니다.
    - 프로세스 간에 통신이 원칙적으로 제한되어 있지만, 그럼에도 불구하고 별도의 통신을 IPC를 통해 수행합니다. 예를 들어 shared memory 방식을 사용하면 커널로부터 프로세스끼리 공유할 메모리를 할당받고, 공유 메모리 공간을 통해 통신을 할 수 있습니다. 다만 공유 자원에 대한 동기화 문제를 해결해야 합니다.

멀티 스레드는

- 하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것입니다
- 장점
    - 일단 하나의 프로세스의 메모리 공간 code, data과 자원을 공유하기 때문에 효율적인 자원활용이 가능합니다. 또한 프로세스의 IPC와 같은 통신을 위한 기술이 필요하지 않습니다.
    - 응답성이 높습니다. 웹 브라우저의 하나의 탭에서 하나의 스레드가 웹 페이지를 다운 받으면, 그와 동시에 다른 스레드가 다운 받은 html을 화면에 출력하는 상황처럼 응답성을 높힐 수 있습니다.
- 단점
    - 여러 스레드끼리 자원을 공유하기 때문에 그에 따른 동기화 문제가 발생할 수 있습니다. 동기화 문제는 뮤텍스, 세마포어 방식을 활용하여 해결할 수 있습니다.
    - 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받습니다.

</details>

<br>

<details>
<summary>IPC에 대해서 설명해보세요</summary>

IPC란 프로세스간에 통신 기법입니다.

프로세스 끼리의 통신은 원칙적으로 제한되어있지만 IPC 기법을 통해 통신을 할 수 있습니다.

대표적으로 shared memory, message passing 기법이 있습니다.

message passing

- 프로세스가 커널을 통해 메시지를 주고 받으며 통신하는 방법입니다.
- 통신하려는 프로세스의 이름을 명시적으로 표시하여 전달하는 direct communication방식과
- mailbox또는 port를 통해 메시지를 간접적으로 전달하는 indirect communication 방식이 있습니다.

shared memory 방식을 사용하면 

- 커널로부터 프로세스끼리 공유할 메모리를 할당받고, 공유 메모리 공간을 통해 통신을 할 수 있습니다. 다만 공유 자원에 대한 동기화 문제를 해결해야 합니다.

</details>

<br>

<details>
<summary>CPU 스케줄링이 무엇인지와 목적을 설명해주세요.</summary>
CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드입니다.
CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 효율적인 CPU 사용을 위해 필요합니다.
</details>

<br>

<details>
<summary>비선점방식과 선점방식을 설명해주세요.</summary>
비선점 방식은 프로세스가 CPU를 점유하고 있는 경우 다른 프로세스가 CPU를 빼앗지 못하는 방식입니다. 비선점방식은 CPU를 중간에 가로채지 않기 때문에 응답시간 예측이 용이하다는 장점이 있지만 중요한 작업이 오래 기다리는 경우가 발생할 수 있다는 단점이 있습니다.
선점 방식은 프로세스가 CPU를 점유하고 있어도 우선 순위가 높은 프로세스가 오면 CPU를 빼앗을 수 있는 방식입니다. 선점방식은 우선 순위가 높은 프로세스가 빠르게 처리할 수 있다는 장점이 있지만 잦은 Context Switching으로 오버헤드가 증가한다는 단점이 있습니다.
</details>

<br>

<details>
<summary>스케줄링 기법 중 FCFS의 단점과 해결 방법을 설명해주세요.</summary>
FCFS 는 대기 큐에 도착한 순서에 따라 CPU를 할당합니다. 그래서 긴 작업이 짧은 작업을 오랫 동안 기다릴 수 있습니다.
단점을 해결하는 방법으로는 준비 큐에서 기다리고 있는 프로세스 중 가장 CPU 요구량이 적은 것을 먼저 실행시켜 주는 SJF(Shortest Job First)가 있습니다.
</details>

<br>

<details>
<summary>프로세스를 동기화 해야하는 이유가 무엇인가요?</summary>
    
공유 데이터에 두 개 이상의 프로세스가 동시에 접근하면 data inconsistency가 발생하기 때문입니다.

- 동기화를 하기 위해서 어떤 이슈를 해결해야하나요??

첫 번째로 어떻게 한 프로세스가 다른 프로세스에게 정보를 넘길 것인지 정해야하고, 두 번쨰로 어떻게 두개 이상의 프로세스가 하나의 데이터에 동시에 접근하지 않도록 할 것인지와 의존 관계가 존재할 때 어떻게 적절한 순서를 부여할 것인지 정해야합니다.
</details>

<br>

<details>
<summary>Race condition은 무엇인가요?</summary>


하나의 공유 데이터에 여러 process가 접근하려 하는 상황이 race condition이라고 한다. 마지막 결과는 정확히 어떤 프로세스가 언제 수행되는지에 따라서 결정됩니다.

- race condition은 언제 발생하나요?

첫 번째는 커널 작업을 수행 중에 인터럽트가 발생할 때와 프로세스가 system call을 하여 커널모드로 진입하여 수행하는 도중 context switch가 발생할 때, 마지막으로 멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근할 때 입니다.
</details>

<br>

<details>
<summary>Critical region은 무엇인가요?</summary>

- Criticla region 문제를 해결하기 위한 세 가지 조건을 말해주세요    
    mutual exclusion, progress, bound waiting입니다. mutual exclusion은 하나의 프로세스가 임계구역에 있을 때 다른 프로세스는 들어갈 수 없는 것이고, progress는 임계구역에 들어간 프로세스가 없다면 어느 프로세스가 들어갈 것인지 적절히 선택해줘야하는 것입니다. 마지막으로 bound waiting 는 그 어떤 프로세스도 임계구역에 들어가기 위해 영원히 기다려서는 안된다는 것입니다.
    

- 이 문제를 해결하기 위한 대표적인 방법에는 무엇이 있나요?
    
    semaphore, mutex, monitor가 있습니다.
    
- Semaphore, mutex, monitor이 무엇인가요?
    
    mutex는 임계 구역을 보호하고 경쟁상태를 방지하기 위한 방법으로 mutex lock을 사용합니다. 프로세스는 임계구역에 들어가기 전에 반드시 락을 획득해야하고, 임계구역을 빠져나올 때 락을 반환해야합니다. mutual exclusion을 제공하지만 bounded waiting 조건을 위배합니다. 왜냐하면 특정 프로세스가 임계구역내에 있을 때 while문을 통해서 반복문에서 빠져나오지 못하기 때문입니다. 프로세스의 시간이 짧을 때 mutex는 유용합니다.
    
    semaphore는 자원의 개수를 뜻합니다. 동시에 자원에 접근할 수 있는 허용가능한 counter의 개수 입니다. 세마포어는 여러 프로세스들에 의해 공유되는 변수로 정의하고 이 변수는 오직 P, V라는 atomic한 연산에 의해서만 접근 가능합니다.
    
    monitor는 mutex와 condition variable을 가지고 있는 동기화 메커니즘으로 상호배제를 함으로써 임계구역에 하나의 프로세스만 들어갈 수 있습니다. monitor는 실제 프로그램에서 세마포어를 구현한 것입니다. 상호 배제를 위한 데이터 및 프로그램 모듈, 운영체제 내부의 프로그램을 모니터라고 한다.
</details>

<br>

<details>
<summary>Mutex vs. Semaphore vs. Monitor를 말해주세요</summary>

- Mutex vs. Semaphore

세마포어는 뮤텍스가 될 수 있지만 무텍스는 세마포어가 될 수 없다. 또 세마포어는 소유할 수 없지만 뮤텍스는 소율할 수 있고 소유한 사람이 반드시 원상태로 돌려놓아야한다. 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 이 뮤텍스를 해제할 수 있다. 하지만 세마포어는 소유하지 않고 있는 다른 스레드가 세마포어를 해제할 수 있다. 뮤텍스는 동기화대상이 1개 세마포어는 동기화 대상이 여러 개일 때 사용한다.

- Semaphore vs. monitor

자바에서는 모니터를 모든 객체에게 기본적으로 제공하지만 c에서는 사용할 수 없다. 세마포어는 카운터라는 변수값으로 프로그래머가 상호배제나 정렬의 목적으로 사용 시 매번 값을 따로 지정해줘야하는 번거로움이 있다. 반면에 모니터는 이러한 일들이 캡슐화되어 있어서 개발자는 카운터 값을 0 또는 1로 주어야하는 고민을 할 필요가 없다.

- monitor vs. mutex

뮤텍스는 다른 프로세스나 스레드 간에 동기화를 위해 사용된다. 모니터는 하나의 프로세스 내에서 다른 스레드 간에 동기화할 때 사용한다. 반면에 모니터는 하나의 프로세스 내에서 다른 스레드 간에 동기화할 때 사용한다. 뮤텍스는 운영체제 커널에 의해서 제공되기 때문에 system call로 인하여 속도가 느리고 그에 반해 모니터는 프레임 워크나 라이브러리 그 자체에서 제공되기 때문에 속도가 빠르다.
</details>

<br>


<details>
<summary></summary>

</details>



<details>
<summary></summary>

</details>
