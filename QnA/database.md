# 💾 Database 면접 예상 질문


<details>
<summary>데이터베이스를 사용하는 이유가 무엇이나요?</summary>

데이터베이스를 사용하기 전에는 파일 시스템을 이용하여 데이터 관리를 했습니다. 

파일 시스템은 응용 프로그램마다 하나의 독립된 데이터 파일을 사용합니다. 그렇기 때문에 한 시스템 내에 데이터가 중복 저장되는 문제가 발생합니다. 또한 응용 프로그램과 데이터 파일의 상호 의존 관계를 갖기 때문에 데이터 파일의 구조가 변경되면 응용 프로그램의 구조 또한 변경해야합니다.

한 시스템에 데이터가 중복 저장되는 파일 시스템은 여러 문제를 야기하는데요. 먼저 하나의 사실만을 나타내도록 일관성을 유지하기 어렵습니다. 그리고 중복 데이터들에 같은 수준의 보안을 유지하기 힘듭니다. 또한 하나의 데이터 파일을 여러 응용 프로그램이 사용하는 상황에서 한 응용 프로그램이 해당 데이터 파일을 사용하고 있다면, 다른 프로그램은 접근하지 못합니다.

위와 같은 파일 시스템의 문제로 여러 응용 프로그램이 특정 데이터를 공유하고, 최소한의 중복으로 저장된 데이터의 집합인 “데이터베이스”가 등장했습니다.

</details>



<details>
<summary>데이터베이스 키의 종류와 기능에 대해 설명해주세요</summary>

데이터베이스에서 키란 검색이나 정렬시에 튜플을 구분할 수 있는 어트리뷰트입니다.

키의 종류에는 슈퍼키, 후보키, 기본키, 대체키, 복합키, 외래키가 있습니다.

1. 슈퍼키는 유일성을 만족하는 어트리뷰트입니다. 유일성을 가진 어트리뷰트는 모든 레코드에서 중복된 값이 없는 어트리뷰트입니다.
2. 후보키는 유일성과 최소성을 만족하는 어트리뷰트입니다. 최소한의 어트리뷰트들로 레코드를 유일하게 구별할 수 있는 속성을 최소성이라고 합니다.
3. 기본키는 유일성과 최소성을 가지며 NULL 값을 가지지 못하는 어트리뷰트입니다. 후보키 가운데 선택된 어트리뷰트라고 할 수 있습니다.
4. 대체키는 후보키 중에서 기본키로 선택된 것들을 제외한 모든 키를 말합니다.
5. 복합키는 한 개 이상의 속성을 포함하는 키를 말합니다.
6. 외래키는 한 테이블에서 다른 테이블의 레코드(튜플)을 참조하기 위해 사용되는 키입니다.

[정리]

- 슈퍼키 = 유일성 만족하는 키
    - 후보키 = 슈퍼키 + 최소성 만족하는 키
        - 기본키 = 후보키 중 선택된 키 = 유일성 + 최소성 + not null = 특정 레코드 구분가능
            - 대체키 = 후보키 - 기본키 = 나머지 키들
- 복합키 = 1 이상의 속성으로 이뤄진 키 = {속성1, .. }
- 외래키 = 다른 테이블의 레코드를 참조하는 키

</details>



<details>
<summary>순차 I/O와 랜덤 I/O에 대해 설명해주세요</summary>

순차 io 란 물리적으로 인접한 데이터를 차례대로 읽는 방식입니다. 따라서 랜덤 io에 비해 큰 처리량을 갖습니다. 순차 io 방식으로 원하는 데이터를 찾기 위해선 full scan을 해야합니다.

랜덤 io란 디스크의 여러 부분에 흩어져 있는 데이터를 읽는 방식입니다. 인접하지 않는 데이터를 읽기 때문에 디스크 헤드가 무작위로 움직입니다. 이는 결국 성능 저하를 야기합니다.

서버 기반의 환경에서는 모든 io를 순차 io로 수행하는것이 불가능합니다. 따라서 하나의 디스크에 여러 데이터를 저장하는 것 보다 여러 디스크에 적은 데이터를 매핑하여 랜덤 엑세스가 최소화 되도록 하는 대응 방식이 있습니다.

</details>

<details>
<summary>Clustering이 무엇인가요?</summary>

데이터베이스 서버에 문제가 발생할 경우에 대비하기 위해 데이터베이스 서버를 여러대로 나누는 기법입니다.

1. active - active 방식으로 여러 대로 나누는 서버를 동작 상태로 두는 방식이 있습니다.
    
    이 방식은 무중단 서비스를 제공할 수 있습니다. 또한 서버 2대가 운영되기 때문에 리소스를 많이 사용하지만 성능적인 측면에 이득이 있습니다. 
    
    하지만 여러 서버가 하나의 저장소에 접근하기 때문에 병목현상이 발생한다는 문제가 있습니다.
    
2. active -standby 방식이 있습니다.
    
    하나의 서버만 운용하고 나머지는 standby로 두는 방식입니다.
    
    따라서 active-active 방식에서 나타나는 병목 현상이 없지만, standby에서 active로 전환하는데 시간이 오래 걸린다는 단점이 있습니다.
    

</details>


<details>
<summary>Replication이 무엇인가요?</summary>

저장된 데이터 손실문제를 해결하기 위해 여러 데이터베이스에 원본 데이터를 복제하는 기법입니다.

원본 데이터를 저장하는 데이터베이스를 primary db라 칭하고 복제 데이터를 백업할 용도의 데이터를 secondary db라고 합니다.

사용자가 crud 요청을 primary db로 보내면 변경된 데이터를 secondary db에 동기화하면서 데이터 일관성을 유지합니다.

또한 secondary db는 백업용도 외에 조회 용도로도 사용할 수 있기 때문에 부하를 분산시킬 수 있습니다.

replication 을 사용하는 이유는

1. 데이터 유실을 막기 위해 사용합니다
2. 또한 primary db가 문제가 생길 경우, secondary db가 그 역할을 대신할 수 있기 때문에 장애 대응을 할 수 있습니다.
3. 여러대의 데이터베이스를 사용하기 때문에 물리적인 거리 차이로 인한 응답 지연 시간을 줄일 수 있습니다.

replication은 primary db에서 secondary db로 데이터를 동기화하는 작업이 필요합니다. 이 때 걸리는 시간을 replication lag이라고 칭합니다.

replica가 많으면 replication lag 시간이 길어지기 때문에, 시간차로 primary db와 secondary db에 동일 데이터를 조회할 경우 결과가 상이할 수 있기 때문에 데이터 일관성을 100% 지키지 못합니다.

</details>


<details>
<summary>Partitioning이 무엇인가요?</summary>

하나의 큰 테이블을 파티션이라는 작은 단위로 나누는 기법입니다.

데이터의 규모가 커지면서 하나의 데이터베이스에 용량이 큰 테이블이 존재하면 성능 이슈가 발생합니다. 이에 대응하기 위해 큰 테이블을 작은 테이블로 작게 쪼개는 파티셔닝 기법이 등장했습니다.

파티셔닝을 하면, full scan 시 탐색 범위를 줄여 성능을 향상시킬 수있습니다.

또한 테이블을 물리적으로 쪼개기 때문에 전체 데이터의 훼손 가능성을 줄여줍니다.

다만 join연산에 대한 비용이 증가한다는 단점이 있습니다.

파티셔닝에는 vertical partitioning, horizontal partitioning 이 있습니다.

1. 수직 파티셔닝이란 용량이 큰 데이터나 민감한 데이터를 담는 attritbute를 독립적인 테이블로 나누는 작업입니다.
2. 수평 파티셔닝이란 스키마가 동일한 테이블을 나누어 저장하는 것을 말합니다. 즉, 스키마가 동일한 테이블이 두개 생기는 것입니다. 이는 sharding과 동일한 개념으로 여길 수 있습니다.

</details>


<details>
<summary>Sharding이 무엇인가요?</summary>

테이블을 행 단위로 나누어서 여러 샤드에 저장하는 방식입니다. 샤드란 샤딩을 통해 나누어진 블록 구간을 말합니다.

이후에 샤드 키를 통해 샤드를 선택하여 데이터를 저장합니다.

샤드를 선택하는 방식은 hash sharding, dynamic sharding, entity group이 있습니다.

해시 샤딩은 해시 함수를 이용하여 데이터를 저장할 샤드를 고르는 방식입니다. 구현이 쉽지만 샤드를 확장할 경우 바람직하지 않는 방법입니다. (해시 함수가 변하여 기존 방식과 다른 저장 방식을 갖게 됩니다)

해시 샤딩의 확장성 문제를 해결하기 위해 다이나믹 샤딩 방식이 등장했습니다. locator service라는 테이블 정보 기반으로 샤드 키를 결정하기 때문에 샤드 확장에 문제가 없습니다. 

다만 locator service가 유실되면 샤드를 고르는데 문제가 발생합니다.

이 두 샤딩 방식은 key-value 쌍의 데이터를 저장하는 NoSQL 데이터베이스에 적합합니다.

데이터간에 관계를 맺는 관계형 데이터베이스에 적합한 샤딩 방식에는 엔티티 그룹이 있습니다. 하나의 샤드 속에 연관된 데이터만 모아두기 때문에 쿼리가 효율적이지만 다른 샤드 내의 엔티티와 연관된 데이터를 조회할 경우 비효율적입니다.

</details>

<details>
<summary>SQL injection 공격 방식에는 무엇이 있나요?</summary>
sql injection 공격 방식에는 두 가지가 존재합니다. 첫 번째는 인증 우회 두 번째는 데이터 노출이 있습니다.

인증 우회는 쿼리를 요청할 때 특정 조건문을 항상 true로 반환하게 쿼리문을 조작하여 보내서 비정상적인 동작을 하도록 조작하는 공격방식입니다.

데이터 노출은 시스템에서 발생하는 에러 메시지를 이용해 공격하는 방법이다. 보통 에러는 개발자가 버그를 수정하는 면에서 도움을 받을 수 있는 존재인데, 해커들은 이를 역이용해 악의적인 구문을 삽입하여 에러를 유발시킨다.

</details>


<details>
<summary>injection을 방어하기 위한 방법은 어떤게 있나요?</summary>

첫 번째로 input값을 받을 시에 특수문자 검사를 진행하는 것 입니다. 로그인 시에 검증 로직을 추가하여 특수문자가 포함되어 있을 시에 요청을 거부하는 방식입니다. 두 번째는 sql 서버 오류시 오류메시지를 감추는 방식입니다. view를 활용해서 사용자가 오류 발생시 메시지를 확인 할 수 없게하여 데이터 노출을 방지합니다. 마지막으로 prepare statement를 이용하는 방법이 있습니다. prepare statement는 서버 측에서 필터링 과정을 거쳐 특수문자를 escaping하는 방식입니다. 이를 통해서 인증 공격을 방지할 수 있습니다.

</details>


<details>
<summary>Join에서 left join과 right join의 차이점은 무엇인가요?</summary>
left join은 a, b 집합이 있을 때, 조인을 진행한후에 교집합을 포함하여 오른쪽테이블에서 null값을 포함하여 결과를 반환하지만, right join은  기준테이블의 오른쪽으로 join하여 데이터를 조회하기때문에 join의 결과 값중에서 왼쪽 데이터가 널인 결과 값도 함께 반환합니다.

</details>



<details>
<summary>SQL 문법 종류와 예시를 들어주세요</summary>
DDL은 (data definition Language) 데이터 정의 언어입니다. 각 릴레이션을 정의하기 위해 존재합니다. alter, drop create table로 릴레이션을 삭제, 생성 및 릴레이션 전환을 합니다. DML은 데이터 조작 언어로 insert, select update가 있고 데이터를 관리하며 각 테이블을 조회 삽입, 갱신합니다. 마지막으로 DCL은 데이터 제어 언어로 사용자별로 데이터의 권한을 다루기 위한 언어로 revoke grant가 있습니다.

<!-- </details>


<details>
<summary></summary>


</details>


<details>
<summary></summary>


</details> -->