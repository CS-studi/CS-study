# 동시성 제어, 교착상태

<br/>

# 트랜잭션 간 동시성 제어

여러 트랜잭션들이 작업을 성공적으로 마치기 위해 트랜잭션 실행 순서를 제어하는 기법

<br/>

> 동시성 제어가 필요한 이유?
> 

동시성이 높다면 데이터베이스의 성능이 좋아지지만, 동시에 데이터 일관성이 깨지기 쉽다. 따라서 트랜잭션간의 동시성 제어를 통해 db 성능과 데이터 일관성을 적절하게 유지할 수 있어야 한다.

<br/>

### 트랜잭션 간에 동시성 제어를 하지 않을 경우 발생하는 주요 문제들

> Dirty Read⭐
> 

commit되지 않은 트랜잭션의 변경 데이터를 read할 경우 발생하는 문제

```python
1. 트랜잭션1이 데이터a를 a'로 갱신함
2. 트랜잭션2가 데이터a'를 읽음
3. 트랜잭션1이 rollback되어 데이터a'가 a로 복구됨

결과적으로 트랜잭션2는 잘못된 데이터(a')를 읽게 된것이다.
```

> Non-repeatable Read⭐
> 

한 트랜잭션 안에서 동일한 쿼리를 두번 수행할 때, 동일한 결과가 나오지 않는 문제

```python
1. 트랜잭션1이 데이터a를 읽음 -> "데이터a : 1"
2. 트랜잭션2가 데이터a를 갱신함 -> "데이터a: 2"
3. 트랜잭션1이 데이터a를 다시 읽음 -> "데이터a: 2" // 이전 결과와 다름
```

> Phantom Read⭐
> 

하나의 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 전에 없던 데이터가 출현하는 문제

```python
1. 트랜잭션1이 where 절로 특정 범위의 레코드를 읽음 -> "데이터a : 1"
2. 트랜잭션2가 데이터b를 추가함
3. 트랜잭션1이 다시 특정 범위의 레코드를 읽음 -> "데이터a : 1, 데이터b : 2" // 전에 없던 데이터b가 등장함.
```

<br/>

### 그 외의 문제들

> Lost Update
> 

하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화되는 문제

```python
1. 트랜잭션1이 데이터a를 1로 갱신
2. 트랜잭션2가 데이터a를 2로 갱신

결과적으로 데이터a는 2라는 값을 가지게 된다.
```

> 데이터 불일치
> 

데이터에 update 연산이 이뤄지는 가운데, 
하나의 트랜잭션은 update 중간에 데이터를 read하고, 다른 트랜잭션은 update 이후에 데이터를 read하여 발생하는 데이터 불일치 문제

```python
1. 트랜잭션1이 데이터a를 10에서 100으로 update하고 있음 
2. 트랜잭션2가 데이터a를 읽음 (10)
3. 트랜잭션1이 데이터a를 update함.
4, 트랜잭션3가 데이터a를 읽음 (100)
```

> Cascading Rollback
> 

```python
1. 트랜잭션1이 데이터a를 갱신하고 있음
2. 트랜잭션2가 갱신중인 데이터a를 읽고 작업을 수행한 뒤 commit함
3. 트랜잭션1이 비정상종료되어 작업을 rollback함.

트랜잭션1이 rollback되어도 이전상태로 돌아가지 못한다. 
왜냐하면 트랜잭션2는 결과적으로 잘못된 데이터a값으로 작업을 마치고 commit하였기 때문이다.
```

> Incorrect Summary
> 

특정 레코드에 집계함수를 적용하는 동안 다른 트랜잭션이 집계 예정 데이터를 변경하여 부정확한 집계 결과를 얻는 문제

<br/>

### 트랜잭션 간에 동시성 제어 방법

Lock 기법이 있다.

<br/>

<br/>

# Lock

트랜잭션이 데이터에 Lock을 걸면, 다른 트랜잭션은 Lock이 걸린 데이터가 Unlock될 때까지 read/write연산을 수행하지 못하도록 제어하는 기법이다.

> DB Lock의 종류
> 
- `Shared Lock(s-lock)` : 트랜잭션이 데이터에 read 연산을 수행할 때 설정하는 lock
    - `s-lock이 걸린 데이터에 다른 트랜잭션이 s-lock을 걸 수 없다. 하지만 x-lock은 걸 수 있다.`
- `Exclusive Lock(x-lock)` : 트랜잭션이 데이터에 write 연산을 수행할 때 설정하는 lock
    - `x-lock이 걸린 데이터에 다른 트랜잭션은 s-lock과 x-lock을 모두 걸 수 없다.`
    

> DB Lock의 단위
> 
1. `Row Level` : 테이블 행에 Lock을 설정
2. `Column Level` : 테이블 열에 Lock을 설정(Column Lock 해제 시 많은 리소스가 소모되어 잘 사용 안됨)
3. `Page Level` : 같은 Page에 존재하는 모든 Row에 Lock을 설정(Page : SQL Server의 기본 IO 단위)
4. `Table Level` : Table과 Index에 Lock을 설정 (DDL Lock이라고 불리기도 함)
5. `Database Level` : 데이터베이스 복구, 스키마 변경시 설정되는 Lock

<br/>

# Blocking

공유 데이터에 lock을 걸려고 하는 트랜잭션들 간에 race condition이 발생한 경우, 동시성 제어를 위해 특정 트랜잭션이 작업을 진행하지 못하게 막은 상태이다.

- `s-lock`이 걸린 데이터에 s-lock을 걸려는 트랜잭션은 blocking되지 않는다.
- `s-lock`이 걸린 데이터에 x-lock을 걸려는 트랜잭션은 blocking된다.
- `x-lock`이 걸린 데이터에 s-lock 또는 x-lock을 걸려는 트랜잭션은 blocking된다.

<br/>

> Blocking을 피하는 방법
> 
- 적절한 쿼리 튜닝을 통해 트랜잭션 수행시간을 짧게 하여 race condition의 가능성을 줄인다
- 동일한 데이터에 write 연산을 하는 트랜잭션이 동시에 수행되지 않도록 설계한다.
- 트랜잭션 격리수준을 필요이상으로 상향 조정하지 않는다.

<br/>

# Dead Lock

서로 다른 두 트랜잭션이 각자 접근하고 있는 데이터 Lock을 걸어 둔 상태에서, 서로의 데이터에 접근하기 위해 Unlock될 때까지 무한정 대기하는 상태이다.

```python
1. 트랜잭션1이 데이터a에 x-lock을 걸어둠
2. 트랜잭션2가 데이터b에 x-lock을 걸어둠
3. 트랜잭션1은 데이터b에, 트랜잭션2는 데이터a에 접근하려고 함

이 때, 트랜잭션1과 2는 데이터b와 a가 unlock될 때까지 blocking되어있기 때문에
서로가 각자 lock을 걸어둔 데이터를 unlock하지 못한다.
```

<br/>

> 트랜잭션 간에 Dead Lock 해결 방안
> 
- Dead Lock이 감지되면 둘 중 하나의 트랜잭션을 강제 종료시킨다.
- 트랜잭션간 데이터 접근 순서 규칙을 정한다.
